"""
Vision module of Modeldeploy.
"""
from __future__ import annotations
import modeldeploy
import numpy
import pybind11_stubgen.typing_ext
import typing
__all__ = ['Classifier', 'ClassifierPostprocessor', 'ClassifierPreprocessor', 'ClassifyResult', 'DBDetector', 'DBDetectorPostprocessor', 'DBDetectorPreprocessor', 'DetectionLandmarkResult', 'DetectionResult', 'FaceAntiSpoofResult', 'FaceRecognitionResult', 'FaceRecognizerPipeline', 'InstanceSegResult', 'LetterBoxRecord', 'LprDetPostprocessor', 'LprDetPreprocessor', 'LprDetection', 'LprPipeline', 'LprRecPostprocessor', 'LprRecPreprocessor', 'LprRecognizer', 'LprResult', 'Mask', 'OCRResult', 'ObbResult', 'PPStructureV2Table', 'PaddleOCR', 'Point2f', 'Point3f', 'PoseResult', 'Recognizer', 'RecognizerPostprocessor', 'RecognizerPreprocessor', 'Rect2f', 'RotatedRect', 'SeetaFaceAge', 'SeetaFaceAgePostprocessor', 'SeetaFaceAgePreprocessor', 'SeetaFaceAsFirst', 'SeetaFaceAsPipeline', 'SeetaFaceAsSecond', 'SeetaFaceGender', 'SeetaFaceGenderPostprocessor', 'SeetaFaceGenderPreprocessor', 'SeetaFaceID', 'SeetaFaceIDPostprocessor', 'SeetaFaceIDPreprocessor', 'StructureV2Layout', 'StructureV2LayoutPostprocessor', 'StructureV2LayoutPreprocessor', 'StructureV2SERViLayoutXLMModel', 'StructureV2Table', 'StructureV2TablePostprocessor', 'StructureV2TablePreprocessor', 'UltralyticsCls', 'UltralyticsClsPostprocessor', 'UltralyticsClsPreprocessor', 'UltralyticsDet', 'UltralyticsObb', 'UltralyticsObbPostprocessor', 'UltralyticsObbPreprocessor', 'UltralyticsPose', 'UltralyticsPosePostprocessor', 'UltralyticsPosePreprocessor', 'UltralyticsPostprocessor', 'UltralyticsPreprocessor', 'UltralyticsSeg', 'UltralyticsSegPostprocessor', 'UltralyticsSegPreprocessor', 'vis_cls', 'vis_det', 'vis_det_landmarks', 'vis_iseg', 'vis_lpr', 'vis_obb', 'vis_ocr', 'vis_pose']
class Classifier(modeldeploy.BaseModel):
    @typing.overload
    def __init__(self, arg0: str, arg1: modeldeploy.RuntimeOption) -> None:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    def batch_predict(self, images: list[numpy.ndarray]) -> OCRResult:
        ...
    def predict(self, image: numpy.ndarray) -> OCRResult:
        ...
    @property
    def postprocessor(self) -> ClassifierPostprocessor:
        ...
    @property
    def preprocessor(self) -> ClassifierPreprocessor:
        ...
class ClassifierPostprocessor:
    cls_thresh: float
    def __init__(self) -> None:
        ...
    @typing.overload
    def run(self, inputs: list[modeldeploy.Tensor]) -> tuple[list[int], list[float]]:
        ...
    @typing.overload
    def run(self, inputs: list[numpy.ndarray]) -> tuple[list[int], list[float]]:
        ...
class ClassifierPreprocessor:
    cls_image_shape: list[int]
    def __init__(self) -> None:
        ...
    def run(self, im_list: list[numpy.ndarray]) -> list[modeldeploy.Tensor]:
        ...
    def set_normalize(self, mean: list[float], std: list[float], is_scale: bool) -> None:
        ...
class ClassifyResult:
    feature: list[float]
    label_ids: list[int]
    scores: list[float]
    def __getstate__(self) -> tuple:
        ...
    def __init__(self) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
class DBDetector(modeldeploy.BaseModel):
    @typing.overload
    def __init__(self, arg0: str, arg1: modeldeploy.RuntimeOption) -> None:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    def batch_predict(self, images: list[numpy.ndarray]) -> list[OCRResult]:
        ...
    def predict(self, image: numpy.ndarray) -> OCRResult:
        ...
    @property
    def postprocessor(self) -> DBDetectorPostprocessor:
        ...
    @property
    def preprocessor(self) -> DBDetectorPreprocessor:
        ...
class DBDetectorPostprocessor:
    det_db_box_thresh: float
    det_db_score_mode: str
    det_db_thresh: float
    det_db_unclip_ratio: float
    use_dilation: int
    def __init__(self) -> None:
        ...
    @typing.overload
    def run(self, inputs: list[modeldeploy.Tensor], batch_det_img_info: list[typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(4)]]) -> list[list[typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(8)]]]:
        ...
    @typing.overload
    def run(self, inputs: list[numpy.ndarray], batch_det_img_info: list[typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(4)]]) -> list[list[typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(8)]]]:
        ...
class DBDetectorPreprocessor:
    max_side_len: int
    static_shape_infer: bool
    def __init__(self) -> None:
        ...
    def run(self, im_list: list[numpy.ndarray]) -> tuple[list[modeldeploy.Tensor], list[typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(4)]]]:
        ...
    def set_normalize(self, arg0: list[float], arg1: list[float], arg2: bool) -> None:
        ...
class DetectionLandmarkResult:
    box: Rect2f
    label_id: int
    landmarks: list[Point2f]
    score: float
    def __getstate__(self) -> tuple:
        ...
    def __init__(self) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
class DetectionResult:
    box: Rect2f
    label_id: int
    score: float
    def __getstate__(self) -> tuple:
        ...
    def __init__(self) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
class FaceAntiSpoofResult:
    """
    Members:
    
      REAL
    
      FUZZY
    
      SPOOF
    """
    FUZZY: typing.ClassVar[FaceAntiSpoofResult]  # value = <FaceAntiSpoofResult.FUZZY: 1>
    REAL: typing.ClassVar[FaceAntiSpoofResult]  # value = <FaceAntiSpoofResult.REAL: 0>
    SPOOF: typing.ClassVar[FaceAntiSpoofResult]  # value = <FaceAntiSpoofResult.SPOOF: 2>
    __members__: typing.ClassVar[dict[str, FaceAntiSpoofResult]]  # value = {'REAL': <FaceAntiSpoofResult.REAL: 0>, 'FUZZY': <FaceAntiSpoofResult.FUZZY: 1>, 'SPOOF': <FaceAntiSpoofResult.SPOOF: 2>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class FaceRecognitionResult:
    embedding: list[float]
    def __getstate__(self) -> tuple:
        ...
    def __init__(self) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
class FaceRecognizerPipeline(modeldeploy.BaseModel):
    def __init__(self, arg0: str, arg1: str, arg2: modeldeploy.RuntimeOption) -> None:
        ...
    def predict(self, image: numpy.ndarray) -> list[FaceRecognitionResult]:
        ...
class InstanceSegResult:
    box: Rect2f
    label_id: int
    mask: Mask
    score: float
    def __getstate__(self) -> tuple:
        ...
    def __init__(self) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
class LetterBoxRecord:
    ipt_h: float
    ipt_w: float
    out_h: float
    out_w: float
    pad_h: float
    pad_w: float
    scale: float
    def __getstate__(self) -> tuple:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def __str__(self) -> str:
        ...
class LprDetPostprocessor:
    conf_threshold: float
    nms_threshold: float
    def __init__(self) -> None:
        ...
    @typing.overload
    def run(self, inputs: list[modeldeploy.Tensor], records: list[LetterBoxRecord]) -> list[list[DetectionLandmarkResult]]:
        ...
    @typing.overload
    def run(self, inputs: list[numpy.ndarray], records: list[LetterBoxRecord]) -> list[list[DetectionLandmarkResult]]:
        ...
    @property
    def landmarks_per_card_(self) -> int:
        ...
    @landmarks_per_card_.setter
    def landmarks_per_card_(self, arg1: float) -> None:
        ...
class LprDetPreprocessor:
    is_mini_pad: bool
    is_scale_up: bool
    padding_value: list[float]
    size: list[int]
    def __init__(self) -> None:
        ...
    def run(self, im_list: list[numpy.ndarray]) -> tuple[list[modeldeploy.Tensor], list[LetterBoxRecord]]:
        ...
    @property
    def stride(self) -> bool:
        ...
    @stride.setter
    def stride(self, arg1: int) -> None:
        ...
class LprDetection(modeldeploy.BaseModel):
    def __init__(self, arg0: str, arg1: modeldeploy.RuntimeOption) -> None:
        ...
    def batch_predict(self, images: list[numpy.ndarray]) -> list[list[DetectionLandmarkResult]]:
        ...
    def predict(self, image: numpy.ndarray) -> list[DetectionLandmarkResult]:
        ...
    @property
    def postprocessor(self) -> LprDetPostprocessor:
        ...
    @property
    def preprocessor(self) -> LprDetPreprocessor:
        ...
class LprPipeline:
    def __init__(self, arg0: str, arg1: str, arg2: modeldeploy.RuntimeOption) -> None:
        ...
    def predict(self, image: numpy.ndarray) -> list[LprResult]:
        ...
class LprRecPostprocessor:
    def __init__(self) -> None:
        ...
    @typing.overload
    def run(self, inputs: list[modeldeploy.Tensor]) -> list[LprResult]:
        ...
    @typing.overload
    def run(self, inputs: list[numpy.ndarray]) -> list[LprResult]:
        ...
class LprRecPreprocessor:
    size: list[int]
    def __init__(self) -> None:
        ...
    def run(self, im_list: list[numpy.ndarray]) -> list[modeldeploy.Tensor]:
        ...
class LprRecognizer(modeldeploy.BaseModel):
    def __init__(self, arg0: str, arg1: modeldeploy.RuntimeOption) -> None:
        ...
    def batch_predict(self, images: list[numpy.ndarray]) -> list[LprResult]:
        ...
    def predict(self, image: numpy.ndarray) -> LprResult:
        ...
    @property
    def postprocessor(self) -> LprRecPostprocessor:
        ...
    @property
    def preprocessor(self) -> LprRecPreprocessor:
        ...
class LprResult:
    box: Rect2f
    car_plate_color: str
    car_plate_str: str
    label_id: int
    landmarks: list[Point2f]
    score: float
    def __getstate__(self) -> tuple:
        ...
    def __init__(self) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
class Mask:
    buffer: list[int]
    shape: list[int]
    def __getstate__(self) -> tuple:
        ...
    def __init__(self) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
class OCRResult:
    boxes: list[typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(8)]]
    cls_labels: list[int]
    cls_scores: list[float]
    rec_scores: list[float]
    table_boxes: list[typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(8)]]
    table_html: str
    table_structure: list[str]
    text: list[str]
    def __init__(self) -> None:
        ...
class ObbResult:
    label_id: int
    rotated_box: RotatedRect
    score: float
    def __getstate__(self) -> tuple:
        ...
    def __init__(self) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
class PPStructureV2Table(modeldeploy.BaseModel):
    rec_batch_size: int
    def __init__(self, det_model_file: str, rec_model_file: str, table_model_file: str, rec_label_file: str, table_char_dict_path: str, max_side_len: int = 960, det_db_thresh: float = 0.3, det_db_box_thresh: float = 0.6, det_db_unclip_ratio: float = 1.5, det_db_score_mode: str = 'slow', use_dilation: bool = False, rec_batch_size: int = 8, option: modeldeploy.RuntimeOption) -> None:
        ...
    def batch_predict(self, images: list[numpy.ndarray]) -> list[OCRResult]:
        ...
    def predict(self, image: numpy.ndarray) -> OCRResult:
        ...
class PaddleOCR(modeldeploy.BaseModel):
    cls_batch_size: int
    rec_batch_size: int
    def __init__(self, det_model_path: str, cls_model_path: str, rec_model_path: str, dict_path: str, max_side_len: int = 960, det_db_thresh: float = 0.3, det_db_box_thresh: float = 0.6, det_db_unclip_ratio: float = 1.5, det_db_score_mode: str = 'slow', use_dilation: bool = False, rec_batch_size: int = 6, option: modeldeploy.RuntimeOption) -> None:
        ...
    def batch_predict(self, images: list[numpy.ndarray]) -> list[OCRResult]:
        ...
    def predict(self, image: numpy.ndarray) -> OCRResult:
        ...
class Point2f:
    x: float
    y: float
    def __getstate__(self) -> tuple:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def __str__(self) -> str:
        ...
class Point3f:
    x: float
    y: float
    z: float
    def __getstate__(self) -> tuple:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def __str__(self) -> str:
        ...
class PoseResult:
    box: Rect2f
    label_id: int
    mask: list[Point3f]
    score: float
    def __getstate__(self) -> tuple:
        ...
    def __init__(self) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
class Recognizer(modeldeploy.BaseModel):
    @typing.overload
    def __init__(self, arg0: str, arg1: str, arg2: modeldeploy.RuntimeOption) -> None:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    def batch_predict(self, images: list[numpy.ndarray]) -> OCRResult:
        ...
    def predict(self, image: numpy.ndarray) -> OCRResult:
        ...
    @property
    def postprocessor(self) -> RecognizerPostprocessor:
        ...
    @property
    def preprocessor(self) -> RecognizerPreprocessor:
        ...
class RecognizerPostprocessor:
    def __init__(self, arg0: str) -> None:
        ...
    @typing.overload
    def run(self, inputs: list[modeldeploy.Tensor]) -> tuple[list[str], list[float]]:
        ...
    @typing.overload
    def run(self, inputs: list[numpy.ndarray]) -> tuple[list[str], list[float]]:
        ...
class RecognizerPreprocessor:
    rec_image_shape: list[int]
    static_shape_infer: bool
    def __init__(self) -> None:
        ...
    def run(self, im_list: list[numpy.ndarray]) -> list[modeldeploy.Tensor]:
        ...
    def set_normalize(self, arg0: list[float], arg1: list[float], arg2: bool) -> None:
        ...
class Rect2f:
    height: float
    width: float
    x: float
    y: float
    def __getstate__(self) -> tuple:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def __str__(self) -> str:
        ...
class RotatedRect:
    angle: float
    height: float
    width: float
    xc: float
    yc: float
    def __getstate__(self) -> tuple:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def __str__(self) -> str:
        ...
class SeetaFaceAge(modeldeploy.BaseModel):
    def __init__(self, arg0: str, arg1: modeldeploy.RuntimeOption) -> None:
        ...
    def batch_predict(self, images: list[numpy.ndarray]) -> list[int]:
        ...
    def predict(self, image: numpy.ndarray) -> int:
        ...
    @property
    def postprocessor(self) -> SeetaFaceAgePostprocessor:
        ...
    @property
    def preprocessor(self) -> SeetaFaceAgePreprocessor:
        ...
class SeetaFaceAgePostprocessor:
    def __init__(self) -> None:
        ...
    @typing.overload
    def run(self, inputs: list[modeldeploy.Tensor]) -> list[int]:
        ...
    @typing.overload
    def run(self, inputs: list[numpy.ndarray]) -> list[int]:
        ...
class SeetaFaceAgePreprocessor:
    size: list[int]
    def __init__(self) -> None:
        ...
    def run(self, im_list: list[numpy.ndarray]) -> list[modeldeploy.Tensor]:
        ...
class SeetaFaceAsFirst(modeldeploy.BaseModel):
    def __init__(self, arg0: str, arg1: modeldeploy.RuntimeOption) -> None:
        ...
    def predict(self, image: numpy.ndarray) -> float:
        ...
class SeetaFaceAsPipeline(modeldeploy.BaseModel):
    def __init__(self, arg0: str, arg1: str, arg2: str, arg3: modeldeploy.RuntimeOption) -> None:
        ...
    def predict(self, image: numpy.ndarray, fuse_threshold: float = 0.8, clarity_threshold: float = 0.3) -> list[FaceAntiSpoofResult]:
        ...
class SeetaFaceAsSecond(modeldeploy.BaseModel):
    def __init__(self, arg0: str, arg1: modeldeploy.RuntimeOption) -> None:
        ...
    def predict(self, image: numpy.ndarray) -> list[tuple[int, float]]:
        ...
class SeetaFaceGender(modeldeploy.BaseModel):
    def __init__(self, arg0: str, arg1: modeldeploy.RuntimeOption) -> None:
        ...
    def batch_predict(self, images: list[numpy.ndarray]) -> list[int]:
        ...
    def predict(self, image: numpy.ndarray) -> int:
        ...
    @property
    def postprocessor(self) -> SeetaFaceGenderPostprocessor:
        ...
    @property
    def preprocessor(self) -> SeetaFaceGenderPreprocessor:
        ...
class SeetaFaceGenderPostprocessor:
    def __init__(self) -> None:
        ...
    @typing.overload
    def run(self, inputs: list[modeldeploy.Tensor]) -> list[int]:
        ...
    @typing.overload
    def run(self, inputs: list[numpy.ndarray]) -> list[int]:
        ...
class SeetaFaceGenderPreprocessor:
    size: list[int]
    def __init__(self) -> None:
        ...
    def run(self, im_list: list[numpy.ndarray]) -> list[modeldeploy.Tensor]:
        ...
class SeetaFaceID(modeldeploy.BaseModel):
    def __init__(self, arg0: str, arg1: modeldeploy.RuntimeOption) -> None:
        ...
    def batch_predict(self, images: list[numpy.ndarray]) -> list[FaceRecognitionResult]:
        ...
    def predict(self, image: numpy.ndarray) -> FaceRecognitionResult:
        ...
    @property
    def postprocessor(self) -> SeetaFaceIDPostprocessor:
        ...
    @property
    def preprocessor(self) -> SeetaFaceIDPreprocessor:
        ...
class SeetaFaceIDPostprocessor:
    def __init__(self) -> None:
        ...
    @typing.overload
    def run(self, inputs: list[modeldeploy.Tensor]) -> list[FaceRecognitionResult]:
        ...
    @typing.overload
    def run(self, inputs: list[numpy.ndarray]) -> list[FaceRecognitionResult]:
        ...
class SeetaFaceIDPreprocessor:
    size: list[int]
    def __init__(self) -> None:
        ...
    def run(self, im_list: list[numpy.ndarray]) -> list[modeldeploy.Tensor]:
        ...
class StructureV2Layout(modeldeploy.BaseModel):
    @typing.overload
    def __init__(self, arg0: str, arg1: modeldeploy.RuntimeOption) -> None:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    def batch_predict(self, images: list[numpy.ndarray]) -> list[list[DetectionResult]]:
        ...
    def predict(self, image: numpy.ndarray) -> list[DetectionResult]:
        ...
    @property
    def postprocessor(self) -> StructureV2LayoutPostprocessor:
        ...
    @property
    def preprocessor(self) -> StructureV2LayoutPreprocessor:
        ...
class StructureV2LayoutPostprocessor:
    fpn_stride: list[int]
    nms_threshold: float
    num_class: int
    reg_max: int
    score_threshold: float
    def __init__(self) -> None:
        ...
    def run(self, inputs: list[modeldeploy.Tensor], batch_layout_img_info: list[typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(4)]]) -> list[list[DetectionResult]]:
        ...
class StructureV2LayoutPreprocessor:
    layout_image_shape: list[int]
    static_shape_infer: bool
    def __init__(self) -> None:
        ...
    def run(self, im_list: list[numpy.ndarray]) -> tuple[list[modeldeploy.Tensor], list[typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(4)]]]:
        ...
    def set_normalize(self, mean: list[float], std: list[float], is_scale: bool) -> None:
        ...
class StructureV2SERViLayoutXLMModel(modeldeploy.BaseModel):
    def __init__(self, arg0: str, arg1: modeldeploy.RuntimeOption) -> None:
        ...
    def batch_predict(self, images: list[numpy.ndarray]) -> None:
        ...
    def get_input_info(self, index: int) -> modeldeploy.TensorInfo:
        ...
    def infer(self, inputs: dict[str, numpy.ndarray]) -> list[numpy.ndarray]:
        ...
    def predict(self, image: numpy.ndarray) -> None:
        ...
class StructureV2Table(modeldeploy.BaseModel):
    @typing.overload
    def __init__(self, arg0: str, arg1: str, arg2: modeldeploy.RuntimeOption) -> None:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    def batch_predict(self, images: list[numpy.ndarray]) -> list[OCRResult]:
        ...
    def predict(self, image: numpy.ndarray) -> OCRResult:
        ...
    @property
    def postprocessor(self) -> StructureV2TablePostprocessor:
        ...
    @property
    def preprocessor(self) -> StructureV2TablePreprocessor:
        ...
class StructureV2TablePostprocessor:
    def __init__(self, arg0: str) -> None:
        ...
    @typing.overload
    def run(self, inputs: list[modeldeploy.Tensor], batch_det_img_info: list[typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(4)]]) -> tuple[list[list[typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(8)]]], list[list[str]]]:
        ...
    @typing.overload
    def run(self, inputs: list[numpy.ndarray], batch_det_img_info: list[typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(4)]]) -> tuple[list[list[typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(8)]]], list[list[str]]]:
        ...
class StructureV2TablePreprocessor:
    def __init__(self) -> None:
        ...
    def run(self, im_list: list[numpy.ndarray]) -> tuple[list[modeldeploy.Tensor], list[typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(4)]]]:
        ...
class UltralyticsCls(modeldeploy.BaseModel):
    def __init__(self, arg0: str, arg1: modeldeploy.RuntimeOption) -> None:
        ...
    def batch_predict(self, images: list[numpy.ndarray]) -> list[ClassifyResult]:
        ...
    def predict(self, image: numpy.ndarray) -> ClassifyResult:
        ...
    @property
    def postprocessor(self) -> UltralyticsClsPostprocessor:
        ...
    @property
    def preprocessor(self) -> UltralyticsClsPreprocessor:
        ...
class UltralyticsClsPostprocessor:
    def __init__(self) -> None:
        ...
    @typing.overload
    def run(self, inputs: list[modeldeploy.Tensor]) -> list[ClassifyResult]:
        ...
    @typing.overload
    def run(self, input_array: list[numpy.ndarray]) -> list[ClassifyResult]:
        ...
class UltralyticsClsPreprocessor:
    size: list[int]
    def __init__(self) -> None:
        ...
    def run(self, im_list: list[numpy.ndarray]) -> list[modeldeploy.Tensor]:
        ...
class UltralyticsDet(modeldeploy.BaseModel):
    def __init__(self, arg0: str, arg1: modeldeploy.RuntimeOption) -> None:
        ...
    def batch_predict(self, images: list[numpy.ndarray]) -> list[list[DetectionResult]]:
        ...
    def predict(self, image: numpy.ndarray) -> list[DetectionResult]:
        ...
    @property
    def postprocessor(self) -> UltralyticsPostprocessor:
        ...
    @property
    def preprocessor(self) -> UltralyticsPreprocessor:
        ...
class UltralyticsObb(modeldeploy.BaseModel):
    def __init__(self, arg0: str, arg1: modeldeploy.RuntimeOption) -> None:
        ...
    def batch_predict(self, images: list[numpy.ndarray]) -> list[list[ObbResult]]:
        ...
    def predict(self, image: numpy.ndarray) -> list[ObbResult]:
        ...
    @property
    def postprocessor(self) -> UltralyticsObbPostprocessor:
        ...
    @property
    def preprocessor(self) -> UltralyticsObbPreprocessor:
        ...
class UltralyticsObbPostprocessor:
    conf_threshold: float
    nms_threshold: float
    def __init__(self) -> None:
        ...
    @typing.overload
    def run(self, inputs: list[modeldeploy.Tensor], records: list[LetterBoxRecord]) -> list[list[ObbResult]]:
        ...
    @typing.overload
    def run(self, inputs: list[numpy.ndarray], records: list[LetterBoxRecord]) -> list[list[ObbResult]]:
        ...
class UltralyticsObbPreprocessor:
    is_mini_pad: bool
    is_scale_up: bool
    padding_value: list[float]
    size: list[int]
    def __init__(self) -> None:
        ...
    def run(self, im_list: list[numpy.ndarray]) -> tuple[list[modeldeploy.Tensor], list[LetterBoxRecord]]:
        ...
    @property
    def stride(self) -> bool:
        ...
    @stride.setter
    def stride(self, arg1: int) -> None:
        ...
class UltralyticsPose(modeldeploy.BaseModel):
    def __init__(self, arg0: str, arg1: modeldeploy.RuntimeOption) -> None:
        ...
    def batch_predict(self, images: list[numpy.ndarray]) -> list[list[PoseResult]]:
        ...
    def predict(self, image: numpy.ndarray) -> list[PoseResult]:
        ...
    @property
    def postprocessor(self) -> UltralyticsPosePostprocessor:
        ...
    @property
    def preprocessor(self) -> UltralyticsPosePreprocessor:
        ...
class UltralyticsPosePostprocessor:
    conf_threshold: float
    nms_threshold: float
    def __init__(self) -> None:
        ...
    @typing.overload
    def run(self, inputs: list[modeldeploy.Tensor], records: list[LetterBoxRecord]) -> list[list[PoseResult]]:
        ...
    @typing.overload
    def run(self, inputs: list[numpy.ndarray], records: list[LetterBoxRecord]) -> list[list[PoseResult]]:
        ...
class UltralyticsPosePreprocessor:
    is_mini_pad: bool
    is_scale_up: bool
    padding_value: list[float]
    size: list[int]
    def __init__(self) -> None:
        ...
    def run(self, im_list: list[numpy.ndarray]) -> tuple[list[modeldeploy.Tensor], list[LetterBoxRecord]]:
        ...
    @property
    def stride(self) -> bool:
        ...
    @stride.setter
    def stride(self, arg1: int) -> None:
        ...
class UltralyticsPostprocessor:
    conf_threshold: float
    nms_threshold: float
    def __init__(self) -> None:
        ...
    @typing.overload
    def run(self, inputs: list[modeldeploy.Tensor], records: list[LetterBoxRecord]) -> list[list[DetectionResult]]:
        ...
    @typing.overload
    def run(self, inputs: list[numpy.ndarray], records: list[LetterBoxRecord]) -> list[list[DetectionResult]]:
        ...
class UltralyticsPreprocessor:
    is_mini_pad: bool
    is_scale_up: bool
    padding_value: list[float]
    size: list[int]
    def __init__(self) -> None:
        ...
    def run(self, im_list: list[numpy.ndarray]) -> tuple[list[modeldeploy.Tensor], list[LetterBoxRecord]]:
        ...
    @property
    def stride(self) -> bool:
        ...
    @stride.setter
    def stride(self, arg1: int) -> None:
        ...
class UltralyticsSeg(modeldeploy.BaseModel):
    def __init__(self, arg0: str, arg1: modeldeploy.RuntimeOption) -> None:
        ...
    def batch_predict(self, images: list[numpy.ndarray]) -> list[list[InstanceSegResult]]:
        ...
    def predict(self, image: numpy.ndarray) -> list[InstanceSegResult]:
        ...
    @property
    def postprocessor(self) -> UltralyticsSegPostprocessor:
        ...
    @property
    def preprocessor(self) -> UltralyticsSegPreprocessor:
        ...
class UltralyticsSegPostprocessor:
    conf_threshold: float
    nms_threshold: float
    def __init__(self) -> None:
        ...
    @typing.overload
    def run(self, inputs: list[modeldeploy.Tensor], records: list[LetterBoxRecord]) -> list[list[InstanceSegResult]]:
        ...
    @typing.overload
    def run(self, inputs: list[numpy.ndarray], records: list[LetterBoxRecord]) -> list[list[InstanceSegResult]]:
        ...
class UltralyticsSegPreprocessor:
    is_mini_pad: bool
    is_scale_up: bool
    padding_value: list[float]
    size: list[int]
    def __init__(self) -> None:
        ...
    def run(self, im_list: list[numpy.ndarray]) -> tuple[list[modeldeploy.Tensor], list[LetterBoxRecord]]:
        ...
    @property
    def stride(self) -> bool:
        ...
    @stride.setter
    def stride(self, arg1: int) -> None:
        ...
def vis_cls(image: numpy.ndarray, result: ClassifyResult, top_k: int, threshold: float, font_path: str = '', font_size: int = 14, alpha: float = 0.5, save_result: bool = False) -> numpy.ndarray:
    ...
def vis_det(image: numpy.ndarray, result: list[DetectionResult], threshold: float = 0.5, font_path: str = '', font_size: int = 14, alpha: float = 0.5, save_result: bool = False) -> numpy.ndarray:
    ...
def vis_det_landmarks(image: numpy.ndarray, result: list[DetectionLandmarkResult], font_path: str = '', font_size: int = 14, landmark_radius: int = 4, alpha: float = 0.5, save_result: bool = False) -> numpy.ndarray:
    ...
def vis_iseg(image: numpy.ndarray, result: list[InstanceSegResult], threshold: float = 0.5, font_path: str = '', font_size: int = 14, alpha: float = 0.5, save_result: bool = False) -> numpy.ndarray:
    ...
def vis_lpr(image: numpy.ndarray, result: list[LprResult], font_path: str = '', font_size: int = 14, landmark_radius: int = 4, alpha: float = 0.5, save_result: bool = False) -> numpy.ndarray:
    ...
def vis_obb(image: numpy.ndarray, result: list[ObbResult], threshold: float = 0.5, font_path: str = '', font_size: int = 14, alpha: float = 0.5, save_result: bool = False) -> numpy.ndarray:
    ...
def vis_ocr(image: numpy.ndarray, result: OCRResult, font_path: str = '', font_size: int = 14, alpha: float = 0.5, save_result: bool = False) -> numpy.ndarray:
    ...
def vis_pose(image: numpy.ndarray, result: list[PoseResult], font_path: str = '', font_size: int = 14, landmark_radius: int = 4, alpha: float = 0.5, save_result: bool = False) -> numpy.ndarray:
    ...
